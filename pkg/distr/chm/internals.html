<html><head><title>Internal functions of package distr</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="Rchm.css">
</head>
<body>

<table width="100%"><tr><td>internals_for_distr(distr)</td><td align="right">R Documentation</td></tr></table><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="keyword" value="R:   internals_for_distr">
<param name="keyword" value="R:   .is.vector.lattice">
<param name="keyword" value="R:   .is.consistent">
<param name="keyword" value="R:   .make.lattice.es.vector">
<param name="keyword" value="R:   .presubs">
<param name="keyword" value="R:   .inArgs">
<param name="keyword" value="R:   .isEqual">
<param name="keyword" value="R:   .isIn">
<param name="keyword" value="R:   .setEqual">
<param name="keyword" value="R:   .isEqual01">
<param name="keyword" value="R:   .makeD">
<param name="keyword" value="R:   .makeP">
<param name="keyword" value="R:   .makeQ">
<param name="keyword" value="R:   .makeDNew">
<param name="keyword" value="R:   .makePNew">
<param name="keyword" value="R:   .makeQNew">
<param name="keyword" value="R:   .makeDd">
<param name="keyword" value="R:   .makePd">
<param name="keyword" value="R:   .makeQd">
<param name="keyword" value="R:   .makeQc">
<param name="keyword" value="R:   .fM2">
<param name="keyword" value="R:   .fM">
<param name="keyword" value="R:   .fm">
<param name="keyword" value="R:   .notwithLArg">
<param name="keyword" value="R:   .multm">
<param name="keyword" value="R:   .plusm">
<param name="keyword" value="R:   .getObjName">
<param name="keyword" value="R:   .discretizeP">
<param name="keyword" value=" Internal functions of package distr">
</object>


<h2>Internal functions of package distr</h2>


<h3>Description</h3>

<p>
These functions are used internally by package distr.
</p>


<h3>Usage</h3>

<pre>
.is.vector.lattice(x)
.is.consistent(lattice, support, eq.space = TRUE)
.make.lattice.es.vector(x)
.inArgs(arg, fct)
.isEqual(p0, p1, tol = min( getdistrOption("TruncQuantile")/2,
                                          .Machine$double.eps^.7))
.isEqual01(x)
.isIn(p0, pmat, tol = min( getdistrOption("TruncQuantile")/2,
                                          .Machine$double.eps^.7
                                          ))
.setEqual(x, y, tol = 1e-7)
.presubs(inp, frompat, topat)
.makeD(object, argList,  stand = NULL)
.makeP(object, argList,  sign = TRUE, correct = NULL)
.makeQ(object, lastCall, sign = TRUE, Cont = TRUE)
.plusm(e1, e2, Dclass = "DiscreteDistribution")
.multm(e1, e2, Dclass = "DiscreteDistribution")
.notwithLArg(D)
.getObjName(i = 1)
.discretizeP(D, lower, upper, h)   
.fm(x,f)
.fM(x,f)
.fM2(x,f)
.makeDd(x,y, yleft, yright)
.makePd(x,y, yleft, yright)
.makeQd(x,y, yleft, yright)
.makeQc(x,y, yleft, yright)
.makeDNew(x, dx, h = NULL, Cont = TRUE, standM = "sum")
.makePNew(x, dx, h = NULL, notwithLLarg = FALSE,
                      Cont = TRUE, myPf = NULL, pxl = NULL, pxu = NULL)
.makeQNew(x, px.l, px.u, notwithLLarg = FALSE, yL , yR, Cont = TRUE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
a (numeric) vector</td></tr>
<tr valign="top"><td><code>y</code></td>
<td>
a (numeric) vector</td></tr>
<tr valign="top"><td><code>f</code></td>
<td>
a function in one (numeric) argument</td></tr>
<tr valign="top"><td><code>lattice</code></td>
<td>
a lattice (of class <code>Lattice</code>)</td></tr>
<tr valign="top"><td><code>support</code></td>
<td>
a support vector</td></tr>
<tr valign="top"><td><code>eq.space</code></td>
<td>
logical: shall we check for the support to be equally spaced?</td></tr>
<tr valign="top"><td><code>arg</code></td>
<td>
a formal argument as character</td></tr>
<tr valign="top"><td><code>fct</code></td>
<td>
a function</td></tr>
<tr valign="top"><td><code>p0,p1</code></td>
<td>
(numeric) vectors</td></tr>
<tr valign="top"><td><code>pmat</code></td>
<td>
(matrix) a matrix with two columns where row-wise the left column
is smaller than the right one</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
an error tolerance (numeric)</td></tr>
<tr valign="top"><td><code>e1</code></td>
<td>
a distribution object</td></tr>
<tr valign="top"><td><code>e2</code></td>
<td>
a numeric</td></tr>
<tr valign="top"><td><code>object</code></td>
<td>
a distribution object</td></tr>
<tr valign="top"><td><code>argList</code></td>
<td>
an (unevaluated) list of arguments passed to <code>m(object)</code>  
where  <code>m</code> is in <code>d,p,q</code></td></tr>
<tr valign="top"><td><code>stand</code></td>
<td>
factor for a (Lebesgue) density to integrate to 1</td></tr>
<tr valign="top"><td><code>sign</code></td>
<td>
the sign of the second operand &mdash; for multiplication at 
the moment</td></tr>
<tr valign="top"><td><code>correct</code></td>
<td>
unevaluated R-code to correct for right-continuity 
(for multiplication with negative numerics at the moment)</td></tr>
<tr valign="top"><td><code>lastCall</code></td>
<td>
unevaluated R-Code &mdash;gives how the result of a call to 
<code>q(e1)</code> is further transformed</td></tr>
<tr valign="top"><td><code>Cont</code></td>
<td>
logical: <code>TRUE</code> if <code>object</code> is continuous</td></tr>
<tr valign="top"><td><code>DClass</code></td>
<td>
character: name of distribution class</td></tr>
<tr valign="top"><td><code>D</code></td>
<td>
a distribution object</td></tr>
<tr valign="top"><td><code>i</code></td>
<td>
an integer</td></tr>
<tr valign="top"><td><code>yleft, yright</code></td>
<td>
extrapolation value beyond left/right endpoint of grid</td></tr>
<tr valign="top"><td><code>h</code></td>
<td>
numeric: grid width</td></tr>
<tr valign="top"><td><code>standM</code></td>
<td>
standardization method &mdash; summation or integration</td></tr>
<tr valign="top"><td><code>notwithLLarg</code></td>
<td>
logical &mdash; can we use <code>log.p</code>, <code>lower.tail</code> 
arguments for <code>p,q</code>-methods of first operand?</td></tr>
<tr valign="top"><td><code>dx</code></td>
<td>
numeric: vector of cell-probabilities for the (discretized) 
distribution</td></tr>
<tr valign="top"><td><code>myPf</code></td>
<td>
function with args <code>x,y, yleft, yright</code> 
(as <code>approxfun</code>): 
if given: replaces <code>approxfun</code> as interpolation method for 
continuos distributions</td></tr>
<tr valign="top"><td><code>pxl,pxu</code></td>
<td>
numeric: if given vector of (lower/upper) cumulative 
probabilities</td></tr>
<tr valign="top"><td><code>yL, yR</code></td>
<td>
argmin / argmax of p()-method</td></tr>
<tr valign="top"><td><code>inp</code></td>
<td>
either a language object or a character vector</td></tr>
<tr valign="top"><td><code>frompat</code></td>
<td>
vector of character strings containing regular expressions (or
character string for <code>fixed = TRUE</code>) to be matched in the
given character vector.  Coerced by <code>as.character</code> to a
character string if possible; (as argument <code>pattern</code> in 
<code><a onclick="findlink('base', 'grep.html')" style="text-decoration: underline; color: blue; cursor: hand">gsub</a></code> &mdash; but possibly of length &gt;1).</td></tr>
<tr valign="top"><td><code>topat</code></td>
<td>
a (vector of) replacement(s) for matched pattern in 
<code>.presubs</code>. 
Coerced to character if possible.  For <code>fixed = FALSE</code> this
can include backreferences <code>"\1"'</code> to <code>"\9"</code> to 
parenthesized subexpressions of <code>pattern</code>.  For 
<code>perl = TRUE</code> only, it can
also contain <code>"\U"</code> or <code>"\L"</code> to convert the rest of the
replacement to upper or lower case; (as argument <code>replacement</code> 
in <code><a onclick="findlink('base', 'grep.html')" style="text-decoration: underline; color: blue; cursor: hand">gsub</a></code>&mdash; but possibly of length &gt;1).</td></tr>
</table>

<h3>Details</h3>

<p>
<code>.is.vector.lattice</code> checks whether a given vector <code>x</code> is equally 
spaced.
<code>.is.consistent</code> checks whether a given support vector <code>support</code> is 
consistent to a given lattice <code>lattice</code> &mdash; with or without checking
if <code>support</code> is equally spaced.  <code>.make.lattice.es.vector</code> 
makes an object of class <code>Lattice</code> out of a given (equally spaced) vector 
<code>x</code>.
</p>
<p>
<code>.inArgs</code> checks whether an argument <code>arg</code> is a formal argument of 
<code>fct</code> &mdash; not vectorized.
</p>
<p>
<code>.isEqual</code> checks whether <code>p0</code> and <code>p1</code> are equal to given
tolerance.
<code>.isIn</code> checks whether <code>p0</code> lies in any of the intervals given by
matrix <code>pmat</code> to given tolerance.
<code>.isEqual01</code>(x) checks whether <code>x</code> is 0 or 1 to given tolerance. 
<code>.setEqual</code> sets all elements of x which are equal to some element of y 
up to tolerance tol, to exactly the respective element of y. 
</p>
<p>
<code>.notwithLArg</code> checks whether object <code>D</code> was generated by simulations 
or if its slots <code>p,q</code> do not have <code>lower.tail</code> arguments.
</p>
<p>
<code>.getObjName</code> returns the name of the object in the <code>i</code>th operand.
<code>.discretizeP</code> discretizes <code>D</code> to a grid of probabilities from 
<code>lower</code> to <code>upper</code> with width <code>h</code>.   
</p>
<p>
<code>.fm</code>, <code>.fM</code> return the smallest / biggest value in (0,1) such that
<code>f</code>(x) is finite; <code>.fM2</code> is a variant of <code>.fM</code> using a 
<code>lower.tail = FALSE</code> argument.
</p>
<p>
<code>.makeD</code>, <code>.makeP</code>, <code>.makeQ</code> generate slots <code>p,d,q</code> for
binary operations <code>e1 /op/ e2</code> for a distribution object <code>e1</code> 
and a numeric <code>e2</code> &mdash;for the moment only <code>/op/</code>'s 
<code>+,-,*,/</code> are implemented.
</p>
<p>
<code>.plusm</code>, <code>.multm</code> more specifically use <code>.makeD</code>, <code>.makeP</code>, 
<code>.makeQ</code> to generate slots <code>p,d,q</code> for <code>+</code>, <code>*</code>, 
respectively. 
</p>
<p>
<code>.makeDd</code>, <code>.makePd</code>, <code>.makeQd</code> provide discrete analogues to 
<code>approxfun</code> for interpolation at non grid-values 
</p>
<p>
<code>.makeQc</code> is an analogue to <code>makeQd</code> for absolutely continuous 
distributions using <code>approxfun</code>. 
</p>
<p>
<code>.makeDNew</code> generates slot <code>d</code> for a new distribution object.
In case of a discrete distribution it produces a step function with 
<code>stepfun</code> (using <code>.makeDd</code>) and standardizes to 1 by summation.
In case of a continuous distribution it produces a density function with 
<code>approxfun</code> and standardizes to 1 by integration if the latter fails,
it uses a trapezoid rule / summation for this purpose.
</p>
<p>
<code>.makePNew</code> generates slot <code>p</code> for a new distribution object.
In case of a discrete distribution it produces a step function from 
<code>cumsum</code> applied to <code>dx</code> &mdash;or from <code>pxl</code> if this is given, with 
<code>stepfun</code> (using <code>.makePd</code>). 
In case of a continuous distribution it produces a cdf with 
<code>approxfun</code>. In case of <code>RtoDPQ</code>, <code>approxfun</code> is replaced by
<code>myPf</code> which calls <code>ecdf</code> directly.
</p>
<p>
<code>.makeQNew</code> generates slot <code>q</code> for a new distribution object.
In case of a discrete distribution it produces a step function 
(using <code>.makeQd</code>). Special care is taken for left continuity...
In case of a continuous distribution it produces a quantile function with 
<code>approxfun</code>.
</p>


<h3>Value</h3>

<table summary="R argblock">
<tr valign="top"><td><code>.is.vector.lattice</code></td>
<td>
<code>logical</code> (length 1)</td></tr>
<tr valign="top"><td><code>.is.consistent</code></td>
<td>
<code>logical</code> (length 1)</td></tr>
<tr valign="top"><td><code>.notwithLArg</code></td>
<td>
<code>logical</code> (length 1)</td></tr>
<tr valign="top"><td><code>.make.lattice.es.vector</code></td>
<td>
an object of class <code>Lattice</code></td></tr>
<tr valign="top"><td><code>.inArgs</code></td>
<td>
<code>logical</code> (length 1)</td></tr>
<tr valign="top"><td><code>.isIn, .isEqual,.isEqual01</code></td>
<td>
vector of <code>logical</code></td></tr>
<tr valign="top"><td><code>.fm,.fM, .fM2</code></td>
<td>
a <code>numeric</code> of length 1</td></tr>
<tr valign="top"><td><code>.plusm,.multm</code></td>
<td>
an object of class <code>DiscreteDistribution</code> or 
<code>AbscontDistribution</code> according to argument <code>DClass</code></td></tr>
<tr valign="top"><td><code>.getObjName</code></td>
<td>
<code>character</code></td></tr>
<tr valign="top"><td><code>.discretizeP</code></td>
<td>
<code>numeric</code> &mdash; the probabilities for the grid-values</td></tr>
<tr valign="top"><td><code>.makeDd,.makePd, .makeQd</code></td>
<td>
a function with args 
<code>x, y, yleft, yright</code></td></tr>
<tr valign="top"><td><code>.makeD,.makeDNew</code></td>
<td>
a function with args <code>x, log = FALSE</code></td></tr>
<tr valign="top"><td><code>.makeP,.makePNew</code></td>
<td>
a function with args <code>q, lower.tail = TRUE, 
       log.p = FALSE</code></td></tr>
<tr valign="top"><td><code>.makeQ,.makeQNew</code></td>
<td>
a function with args <code>p, lower.tail = TRUE, 
       log.p = FALSE</code></td></tr>
</table>

<h3>Author(s)</h3>

<p>
Peter Ruckdeschel <a href="mailto:Peter.Ruckdeschel@uni-bayreuth.de">Peter.Ruckdeschel@uni-bayreuth.de</a>
</p>


<h3>See Also</h3>

<p>
<code><a href="LatticeDistribution-class.html">LatticeDistribution</a></code>,
<code><a href="RtoDPQ.html">RtoDPQ</a></code>,
<code><a href="RtoDPQ.d.html">RtoDPQ.d</a></code>,
<code><a href="ConvPow.html">convpow</a></code>,
<code><a href="operators-methods.html">operators</a></code>,
<code><a href="plot-methods.html">plot-methods</a></code>
</p>

<script Language="JScript">
function findlink(pkg, fn) {
var Y, link;
Y = location.href.lastIndexOf("\\") + 1;
link = location.href.substring(0, Y);
link = link + "../../" + pkg + "/chtml/" + pkg + ".chm::/" + fn;
location.href = link;
}
</script>


<hr><div align="center">[Package <em>distr</em> version 2.0 <a href="00Index.html">Index]</a></div>

</body></html>
