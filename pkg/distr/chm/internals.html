<html><head><title>Internal functions of package distr</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="Rchm.css">
</head>
<body>

<table width="100%"><tr><td>internals_for_distr(distr)</td><td align="right">R Documentation</td></tr></table><object type="application/x-oleobject" classid="clsid:1e2a7bd0-dab9-11d0-b93a-00c04fc99f9e">
<param name="keyword" value="R:   internals_for_distr">
<param name="keyword" value="R:   .is.vector.lattice">
<param name="keyword" value="R:   .is.consistent">
<param name="keyword" value="R:   .isInteger">
<param name="keyword" value="R:   .isNatural">
<param name="keyword" value="R:   .isNatural0">
<param name="keyword" value="R:   .mergegaps">
<param name="keyword" value="R:   .mergegaps2">
<param name="keyword" value="R:   .pmixfun">
<param name="keyword" value="R:   .dmixfun">
<param name="keyword" value="R:   .qmixfun">
<param name="keyword" value="R:   .rmixfun">
<param name="keyword" value="R:   .loupmixfun">
<param name="keyword" value="R:   .make.lattice.es.vector">
<param name="keyword" value="R:   .presubs">
<param name="keyword" value="R:   .inArgs">
<param name="keyword" value="R:   .isEqual">
<param name="keyword" value="R:   .isIn">
<param name="keyword" value="R:   .setEqual">
<param name="keyword" value="R:   .isEqual01">
<param name="keyword" value="R:   .makeD">
<param name="keyword" value="R:   .makeP">
<param name="keyword" value="R:   .makeQ">
<param name="keyword" value="R:   .makeDNew">
<param name="keyword" value="R:   .makePNew">
<param name="keyword" value="R:   .makeQNew">
<param name="keyword" value="R:   .makeDd">
<param name="keyword" value="R:   .makePd">
<param name="keyword" value="R:   .makeQd">
<param name="keyword" value="R:   .makeQc">
<param name="keyword" value="R:   .fM2">
<param name="keyword" value="R:   .fM">
<param name="keyword" value="R:   .fm">
<param name="keyword" value="R:   .notwithLArg">
<param name="keyword" value="R:   .multm">
<param name="keyword" value="R:   .plusm">
<param name="keyword" value="R:   .getObjName">
<param name="keyword" value="R:   .discretizeP">
<param name="keyword" value="R:   .expm.d">
<param name="keyword" value="R:   .expm.c">
<param name="keyword" value="R:   .logm.d">
<param name="keyword" value="R:   .logm.c">
<param name="keyword" value="R:   .P2D">
<param name="keyword" value="R:   .P2Q">
<param name="keyword" value="R:   .D2P">
<param name="keyword" value="R:   .Q2P">
<param name="keyword" value="R:   .csimpsum">
<param name="keyword" value="R:   .primefun">
<param name="keyword" value="R:   devNew">
<param name="keyword" value=" Internal functions of package distr">
</object>


<h2>Internal functions of package distr</h2>


<h3>Description</h3>

<p>
These functions are used internally by package distr.
</p>


<h3>Usage</h3>

<pre>
.is.vector.lattice(x)
.is.consistent(lattice, support, eq.space = TRUE)
.make.lattice.es.vector(x)
.inArgs(arg, fct)
.isEqual(p0, p1, tol = min( getdistrOption("TruncQuantile")/2,
                                          .Machine$double.eps^.7))
.isEqual01(x)
.isIn(p0, pmat, tol = min( getdistrOption("TruncQuantile")/2,
                                          .Machine$double.eps^.7
                                          ))
.isInteger(x, tol = .Machine$double.eps)
.isNatural(x, tol = .Machine$double.eps)
.isNatural0(x, tol = .Machine$double.eps)
.setEqual(x, y, tol = 1e-7)
.presubs(inp, frompat, topat)
.makeD(object, argList,  stand = NULL, fac = NULL)
.makeP(object, argList,  sign = TRUE, correct = NULL, fac =
                 NULL, fac2 = NULL)
.makeQ(object, lastCall, sign = TRUE, Cont = TRUE)
.plusm(e1, e2, Dclass = "DiscreteDistribution")
.multm(e1, e2, Dclass = "DiscreteDistribution")
.notwithLArg(D)
.getObjName(i = 1)
.discretizeP(D, lower, upper, h)
.fm(x,f)
.fM(x,f)
.fM2(x,f)
.makeDd(x,y, yleft, yright)
.makePd(x,y, yleft, yright)
.makeQd(x,y, yleft, yright)
.makeQc(x,y, yleft, yright)
.makeDNew(x, dx, h = NULL, Cont = TRUE, standM = "sum")
.makePNew(x, dx, h = NULL, notwithLLarg = FALSE,
                      Cont = TRUE, myPf = NULL, pxl = NULL, pxu = NULL)
.makeQNew(x, px.l, px.u, notwithLLarg = FALSE, yL , yR, Cont = TRUE)
.mergegaps(gaps, support)
.mergegaps2(gaps1, gaps2)
.pmixfun(mixDistr, mixCoeff)
.dmixfun(mixDistr, mixCoeff, withStand = FALSE, supp = NULL)
.rmixfun(mixDistr, mixCoeff)
.qmixfun(mixDistr, mixCoeff, Cont = TRUE, pnew)
.loupmixfun(mixDistr)
.expm.d(e1)
.expm.c(e1)
.logm.d(e1)
.logm.c(e1)
.P2D (p, xx, ql, qu, ngrid = getdistrOption("DefaultNrGridPoints"))
.P2Q (p, xx, ql,qu, ngrid = getdistrOption("DefaultNrGridPoints"), 
                qL = -Inf, qU = Inf)
.D2P (d, xx, ql, qu,  ngrid = getdistrOption("DefaultNrGridPoints"))
.Q2P (q, ngrid = getdistrOption("DefaultNrGridPoints"))
.csimpsum(fx)
.primefun(f,x, nm = NULL)
devNew(...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
a (numeric) vector</td></tr>
<tr valign="top"><td><code>y</code></td>
<td>
a (numeric) vector</td></tr>
<tr valign="top"><td><code>f</code></td>
<td>
a function in one (numeric) argument</td></tr>
<tr valign="top"><td><code>lattice</code></td>
<td>
a lattice (of class <code>Lattice</code>)</td></tr>
<tr valign="top"><td><code>support</code></td>
<td>
a support vector</td></tr>
<tr valign="top"><td><code>eq.space</code></td>
<td>
logical: shall we check for the support to be equally spaced?</td></tr>
<tr valign="top"><td><code>arg</code></td>
<td>
a formal argument as character</td></tr>
<tr valign="top"><td><code>fct</code></td>
<td>
a function</td></tr>
<tr valign="top"><td><code>p0,p1</code></td>
<td>
(numeric) vectors</td></tr>
<tr valign="top"><td><code>pmat</code></td>
<td>
(matrix) a matrix with two columns where row-wise the left column
is smaller than the right one</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
an error tolerance (numeric)</td></tr>
<tr valign="top"><td><code>e1</code></td>
<td>
a distribution object</td></tr>
<tr valign="top"><td><code>e2</code></td>
<td>
a numeric</td></tr>
<tr valign="top"><td><code>object</code></td>
<td>
a distribution object</td></tr>
<tr valign="top"><td><code>argList</code></td>
<td>
an (unevaluated) list of arguments passed to <code>m(object)</code>  
where  <code>m</code> is in <code>d,p,q</code></td></tr>
<tr valign="top"><td><code>stand</code></td>
<td>
factor for a (Lebesgue) density to integrate to 1</td></tr>
<tr valign="top"><td><code>sign</code></td>
<td>
the sign of the second operand &mdash; for multiplication at 
the moment</td></tr>
<tr valign="top"><td><code>correct</code></td>
<td>
unevaluated R-code to correct for right-continuity 
(for multiplication with negative numerics at the moment)</td></tr>
<tr valign="top"><td><code>fac</code></td>
<td>
factor to be multiplied with the return value</td></tr>
<tr valign="top"><td><code>fac2</code></td>
<td>
factor to be added to the return value</td></tr>
<tr valign="top"><td><code>lastCall</code></td>
<td>
unevaluated R-Code &mdash;gives how the result of a call to 
<code>q(e1)</code> is further transformed</td></tr>
<tr valign="top"><td><code>Cont</code></td>
<td>
logical: <code>TRUE</code> if <code>object</code> is continuous</td></tr>
<tr valign="top"><td><code>DClass</code></td>
<td>
character: name of distribution class</td></tr>
<tr valign="top"><td><code>D</code></td>
<td>
a distribution object</td></tr>
<tr valign="top"><td><code>i</code></td>
<td>
an integer</td></tr>
<tr valign="top"><td><code>yleft, yright</code></td>
<td>
extrapolation value beyond left/right endpoint of grid</td></tr>
<tr valign="top"><td><code>h</code></td>
<td>
numeric: grid width</td></tr>
<tr valign="top"><td><code>standM</code></td>
<td>
standardization method &mdash; summation or integration</td></tr>
<tr valign="top"><td><code>notwithLLarg</code></td>
<td>
logical &mdash; can we use <code>log.p</code>, <code>lower.tail</code> 
arguments for <code>p,q</code>-methods of first operand?</td></tr>
<tr valign="top"><td><code>dx</code></td>
<td>
numeric: vector of cell-probabilities for the (discretized) 
distribution</td></tr>
<tr valign="top"><td><code>myPf</code></td>
<td>
function with args <code>x,y, yleft, yright</code> 
(as <code>approxfun</code>): 
if given: replaces <code>approxfun</code> as interpolation method for 
continuos distributions</td></tr>
<tr valign="top"><td><code>pxl,pxu</code></td>
<td>
numeric: if given vector of (lower/upper) cumulative 
probabilities</td></tr>
<tr valign="top"><td><code>yL, yR</code></td>
<td>
argmin / argmax of p()-method</td></tr>
<tr valign="top"><td><code>inp</code></td>
<td>
either a language object or a character vector</td></tr>
<tr valign="top"><td><code>frompat</code></td>
<td>
vector of character strings containing regular expressions (or
character string for <code>fixed = TRUE</code>) to be matched in the
given character vector.  Coerced by <code>as.character</code> to a
character string if possible; (as argument <code>pattern</code> in 
<code><a onclick="findlink('base', 'grep.html')" style="text-decoration: underline; color: blue; cursor: hand">gsub</a></code> &mdash; but possibly of length &gt;1).</td></tr>
<tr valign="top"><td><code>topat</code></td>
<td>
a (vector of) replacement(s) for matched pattern in 
<code>.presubs</code>. 
Coerced to character if possible.  For <code>fixed = FALSE</code> this
can include backreferences <code>"\1"'</code> to <code>"\9"</code> to 
parenthesized subexpressions of <code>pattern</code>.  For 
<code>perl = TRUE</code> only, it can
also contain <code>"\U"</code> or <code>"\L"</code> to convert the rest of the
replacement to upper or lower case; (as argument <code>replacement</code> 
in <code><a onclick="findlink('base', 'grep.html')" style="text-decoration: underline; color: blue; cursor: hand">gsub</a></code>&mdash; but possibly of length &gt;1).</td></tr>
<tr valign="top"><td><code>gaps,gaps1,gaps2</code></td>
<td>
matrices <code>m</code> with two columns, 
such that <code>t(m)</code>, interpreted as vector, is ordered</td></tr>
<tr valign="top"><td><code>support</code></td>
<td>
support vector of a univariate discrete distribution</td></tr>
<tr valign="top"><td><code>mixDistr</code></td>
<td>
an object of class <code>UnivarDistrList</code></td></tr>
<tr valign="top"><td><code>mixCoeff</code></td>
<td>
an object of class <code>numeric</code>; a probability vector</td></tr>
<tr valign="top"><td><code>pnew</code></td>
<td>
a function <code>function(q, lower.tail = TRUE, log.p = FALSE</code>
realizing slot <code>p</code> in a distribution object.</td></tr>
<tr valign="top"><td><code>withStand</code></td>
<td>
logical; if <code>TRUE</code> a standardization is made such
that the sum of the values of the result evaluated at argument <code>supp</code> is 1</td></tr>
<tr valign="top"><td><code>supp</code></td>
<td>
NULL or <code>numeric</code>; if <code>withStand</code> is <code>TRUE</code> used
to standardize such that the result is a probability density.</td></tr>
<tr valign="top"><td><code>p</code></td>
<td>
slot <code>p</code> of an object of class <code>"AbscontDistribution"</code></td></tr>
<tr valign="top"><td><code>d</code></td>
<td>
slot <code>d</code> of an object of class <code>"AbscontDistribution"</code></td></tr>
<tr valign="top"><td><code>q</code></td>
<td>
slot <code>q</code> of an object of class <code>"AbscontDistribution"</code></td></tr>
<tr valign="top"><td><code>xx</code></td>
<td>
a given grid of x-values for functions <code>p</code>, <code>d</code> to be
evaluated at</td></tr>
<tr valign="top"><td><code>ql,qu</code></td>
<td>
lower and upper <code>getdistrOption("TruncQuantile")</code>-quantile of
the distribution; also, if argument <code>xx</code> is missing, left and right endpoint
of a regular grid of <code>ngrid</code> gridpoints to be used in place of <code>xx</code>.</td></tr>
<tr valign="top"><td><code>qL,qU</code></td>
<td>
argmin / argmax of p()-method</td></tr>
<tr valign="top"><td><code>ngrid</code></td>
<td>
number of gridpoints</td></tr>
<tr valign="top"><td><code>fx</code></td>
<td>
a vector of function evaluations multiplied by the gridwidth</td></tr>
<tr valign="top"><td><code>f</code></td>
<td>
a vector of function evaluations</td></tr>
<tr valign="top"><td><code>nm</code></td>
<td>
an optional right asymptotic value</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
arguments passed through to other functions</td></tr>
</table>

<h3>Details</h3>

<p>
<code>.is.vector.lattice</code> checks whether a given vector <code>x</code> is equally 
spaced.
<code>.is.consistent</code> checks whether a given support vector <code>support</code> is 
consistent to a given lattice <code>lattice</code> &mdash; with or without checking
if <code>support</code> is equally spaced.  <code>.make.lattice.es.vector</code> 
makes an object of class <code>Lattice</code> out of a given (equally spaced) vector 
<code>x</code>.
</p>
<p>
<code>.inArgs</code> checks whether an argument <code>arg</code> is a formal argument of 
<code>fct</code> &mdash; not vectorized.
</p>
<p>
<code>.isEqual</code> checks whether <code>p0</code> and <code>p1</code> are equal to given
tolerance.
<code>.isIn</code> checks whether <code>p0</code> lies in any of the intervals given by
matrix <code>pmat</code> to given tolerance.
<code>.isEqual01</code>(x) checks whether <code>x</code> is 0 or 1 to given tolerance. 
<code>.setEqual</code> sets all elements of x which are equal to some element of y 
up to tolerance tol, to exactly the respective element of y. 
</p>
<p>
<code>.notwithLArg</code> checks whether object <code>D</code> was generated by simulations 
or if its slots <code>p,q</code> do not have <code>lower.tail</code> arguments.
</p>
<p>
<code>.getObjName</code> returns the name of the object in the <code>i</code>th operand.
<code>.discretizeP</code> discretizes <code>D</code> to a grid of probabilities from 
<code>lower</code> to <code>upper</code> with width <code>h</code>.   
</p>
<p>
<code>.fm</code>, <code>.fM</code> return the smallest / biggest value in (0,1) such that
<code>f</code>(x) is finite; <code>.fM2</code> is a variant of <code>.fM</code> using a 
<code>lower.tail = FALSE</code> argument.
</p>
<p>
<code>.makeD</code>, <code>.makeP</code>, <code>.makeQ</code> generate slots <code>p,d,q</code> for
binary operations <code>e1 /op/ e2</code> for a distribution object <code>e1</code> 
and a numeric <code>e2</code> &mdash;for the moment only <code>/op/</code>'s 
<code>+,-,*,/</code> are implemented.
</p>
<p>
<code>.plusm</code>, <code>.multm</code> more specifically use <code>.makeD</code>, <code>.makeP</code>, 
<code>.makeQ</code> to generate slots <code>p,d,q</code> for <code>+</code>, <code>*</code>, 
respectively. 
</p>
<p>
<code>.makeDd</code>, <code>.makePd</code>, <code>.makeQd</code> provide discrete analogues to 
<code>approxfun</code> for interpolation at non grid-values 
</p>
<p>
<code>.makeQc</code> is an analogue to <code>makeQd</code> for absolutely continuous 
distributions using <code>approxfun</code>. 
</p>
<p>
<code>.makeDNew</code> generates slot <code>d</code> for a new distribution object.
In case of a discrete distribution it produces a step function with 
<code>stepfun</code> (using <code>.makeDd</code>) and standardizes to 1 by summation.
In case of a continuous distribution it produces a density function with 
<code>approxfun</code> and standardizes to 1 by integration if the latter fails,
it uses a trapezoid rule / summation for this purpose.
</p>
<p>
<code>.makePNew</code> generates slot <code>p</code> for a new distribution object.
In case of a discrete distribution it produces a step function from 
<code>cumsum</code> applied to <code>dx</code> &mdash;or from <code>pxl</code> if this is given, with 
<code>stepfun</code> (using <code>.makePd</code>). 
In case of a continuous distribution it produces a cdf with 
<code>approxfun</code>. In case of <code>RtoDPQ</code>, <code>approxfun</code> is replaced by
<code>myPf</code> which calls <code>ecdf</code> directly.
</p>
<p>
<code>.makeQNew</code> generates slot <code>q</code> for a new distribution object.
In case of a discrete distribution it produces a step function 
(using <code>.makeQd</code>). Special care is taken for left continuity...
In case of a continuous distribution it produces a quantile function with 
<code>approxfun</code>. 
</p>
<p>
<code>.isInteger</code>, <code>.isNatural</code>, and <code>.isNatural0</code> test for each 
coordinate of argument <code>x</code> whether it
is integer [natural / natural or 0] or not.
</p>
<p>
<code>.mergegaps</code> modifies the gaps matrix of an a.c. distribution according to
the support slot of a discrete distribution; if necessary, a gap interval
[a,b] is split into [a,c],[c,b] if <code>a&lt;c&lt;b</code>.
<code>.mergegaps2</code> merges two gap matrices of two a.c. distributions <code>X1</code> 
and <code>X2</code> such that in the intervals of the resulting gap matrix, 
neither <code>X1</code> nor <code>X2</code> carries mass.
</p>
<p>
<code>.pmixfun</code>, <code>.dmixfun</code>, <code>.rmixfun</code>, and <code>.qmixfun</code>
fill the slots <code>p</code>, <code>d</code>, <code>r</code>, and <code>q</code>
of a corresponding mixing distribution according to the arguments
in <code>mixDistr</code>, <code>mixCoeff</code>.
</p>
<p>
<code>.loupmixfun</code> finds commun lower and upper bounds for the support of
the mixing distribution.
<code>.expm.d,.expm.c</code> for discrete, resp. a.c. argument <code>e1</code> fill the 
slots <code>p</code>, <code>d</code>, <code>r</code>, and <code>q</code>
of the transformation <code>exp(e1)</code> exactly.
<code>.logm.d,.logm.c</code> for discrete, resp. a.c. argument <code>e1</code> fill the 
slots <code>p</code>, <code>d</code>, <code>r</code>, and <code>q</code>
of the transformation <code>log(e1)</code> exactly.
</p>
<p>
For objects of class <code><a href="ContDistribution.html">AbscontDistribution</a></code>,
<code>.P2D</code> and <code>.P2Q</code> reconstruct function slots <code>d</code> resp. 
<code>q</code> from function slot <code>p</code>
by means of function <code>D1ss</code> from package <span class="pkg">sfsmisc</span>;
and of function <code>.makeQNew</code>,  respectively. The other way round, 
<code>.D2P</code> and <code>.Q2P</code> reconstruct function slot <code>p</code> from 
from function slots  <code>d</code> resp. <code>q</code> 
by means of function <code>.makePNew</code> and explicite numeric inversion,  
respectively.
</p>
<p>
<code>.csimpsum</code> is used internally in <code>.makePNew</code> to produce
a prime function out of function evaluations by means of vectorized
Simpson quadrature method, returning already the function values
of the prime function on a grid; it is to mimick the behaviour
of <code>cumsum</code>. <code>.primefun</code> is similar but more flexible and
produces the prime function as a function.
</p>
<p>
<code>devNew</code> opens a new device. This function is for back compatibility
with R versions &lt; 2.8.0.
</p>


<h3>Value</h3>

<table summary="R argblock">
<tr valign="top"><td><code>.is.vector.lattice</code></td>
<td>
<code>logical</code> (length 1)</td></tr>
<tr valign="top"><td><code>.is.consistent</code></td>
<td>
<code>logical</code> (length 1)</td></tr>
<tr valign="top"><td><code>.notwithLArg</code></td>
<td>
<code>logical</code> (length 1)</td></tr>
<tr valign="top"><td><code>.make.lattice.es.vector</code></td>
<td>
an object of class <code>Lattice</code></td></tr>
<tr valign="top"><td><code>.inArgs</code></td>
<td>
<code>logical</code> (length 1)</td></tr>
<tr valign="top"><td><code>.isIn, .isEqual,.isEqual01</code></td>
<td>
vector of <code>logical</code></td></tr>
<tr valign="top"><td><code>.fm,.fM, .fM2</code></td>
<td>
a <code>numeric</code> of length 1</td></tr>
<tr valign="top"><td><code>.plusm,.multm</code></td>
<td>
an object of class <code>DiscreteDistribution</code> or 
<code>AbscontDistribution</code> according to argument <code>DClass</code></td></tr>
<tr valign="top"><td><code>.getObjName</code></td>
<td>
<code>character</code></td></tr>
<tr valign="top"><td><code>.discretizeP</code></td>
<td>
<code>numeric</code> &mdash; the probabilities for the grid-values</td></tr>
<tr valign="top"><td><code>.makeDd,.makePd, .makeQd</code></td>
<td>
a function with args 
<code>x, y, yleft, yright</code></td></tr>
<tr valign="top"><td><code>.makeD,.makeDNew</code></td>
<td>
a function with args <code>x, log = FALSE</code></td></tr>
<tr valign="top"><td><code>.makeP,.makePNew</code></td>
<td>
a function with args <code>q, lower.tail = TRUE, 
       log.p = FALSE</code></td></tr>
<tr valign="top"><td><code>.makeQ,.makeQNew</code></td>
<td>
a function with args <code>p, lower.tail = TRUE, 
       log.p = FALSE</code></td></tr>
<tr valign="top"><td><code>.isInteger,.isNatural,.isNatural0</code></td>
<td>
<code>logical</code> (same length as argument <code>x</code>)</td></tr>
<tr valign="top"><td><code>.mergegaps,.mergegaps2</code></td>
<td>
a <code>gaps</code>-matrix, i.e.; a matrix <code>m</code> with two columns, 
such that <code>t(m)</code>, interpreted as vector, is ordered</td></tr>
<tr valign="top"><td><code>.pmixfun</code></td>
<td>
slot <code>p</code> for a mixing distribution, i.e. a function 
<code>function(q, lower.tail = TRUE, log.p = FALSE)</code>, which
is  the cdf of the distribution</td></tr>
<tr valign="top"><td><code>.dmixfun</code></td>
<td>
slot <code>d</code> for a mixing distribution, i.e. a function 
<code>function(x, log = FALSE)</code>, which
is  the density of the distribution</td></tr>
<tr valign="top"><td><code>.qmixfun</code></td>
<td>
slot <code>q</code> for a mixing distribution, i.e. a function 
<code>function(p, lower.tail = TRUE, log.p = FALSE)</code>, which
is  the quantile function of the distribution</td></tr>
<tr valign="top"><td><code>.rmixfun</code></td>
<td>
slot <code>r</code> for a mixing distribution, i.e. a function 
<code>function(n)</code> generating r.v.'s according to the distribution</td></tr>
<tr valign="top"><td><code>.loupmixfun</code></td>
<td>
a list of four components: <code>qL</code>, the minimal value of 
<code>q(x)(0)</code>, <code>ql</code>, the minimal value of 
<code>q(x)(getdistrOption("TruncQuantile"))</code>, <code>qU</code>, the maximal value of 
<code>q(x)(1)</code>, <code>qu</code>, the maximal value of 
<code>q(x)(getdistrOption("TruncQuantile"), lower.tail = FALSE)</code>,
<code>x</code> running through the members of <code>mixDistr</code> in each case.</td></tr>
<tr valign="top"><td><code>.expm.d,.logm.d</code></td>
<td>
an object of class <code>"DiscreteDistribution"</code>.</td></tr>
<tr valign="top"><td><code>.expm.c,.logm.c</code></td>
<td>
an object of class <code>"AbscontDistribution"</code>.</td></tr>
</table>
<p>
 
<code>.P2D</code>{a density <code>d</code> as function <code>function(x,  log = FALSE)</code>}
<code>.P2Q</code>{a quantile function <code>q</code> as function <code>function(p, 
            lower.tail = TRUE, log.p = FALSE)</code>} 
<code>.D2P, .Q2P</code>{a cdf <code>p</code> as function <code>function(q, 
            lower.tail = TRUE, log.p = FALSE)</code>}
<code>.csimpsum</code>{a vector of evaluations of the prime function at the grid points}
<code>.primefun</code>{the prime function as a function}
<code>devNew</code>{returns the return value of the device opened, usually invisible 'NULL'}</p>

<h3>Author(s)</h3>

<p>
Peter Ruckdeschel <a href="mailto:Peter.Ruckdeschel@itwm.fraunhofer.de">Peter.Ruckdeschel@itwm.fraunhofer.de</a>
Matthias Kohl <a href="mailto:Matthias.Kohl@stamats.de">Matthias.Kohl@stamats.de</a>
</p>


<h3>See Also</h3>

<p>
<code><a href="ContDistribution.html">AbscontDistribution</a></code>,
<code><a href="DiscreteDistribution.html">DiscreteDistribution</a></code>,
<code><a href="LatticeDistribution.html">LatticeDistribution</a></code>,
<code><a href="RtoDPQ.html">RtoDPQ</a></code>,
<code><a href="RtoDPQ.d.html">RtoDPQ.d</a></code>,
<code><a href="ConvPow.html">convpow</a></code>,
<code><a href="operators-methods.html">operators</a></code>,
<code><a href="plot-methods.html">plot-methods</a></code>
<code><a onclick="findlink('grDevices', 'dev.new.html')" style="text-decoration: underline; color: blue; cursor: hand">dev.new</a></code>
</p>

<script Language="JScript">
function findlink(pkg, fn) {
var Y, link;
Y = location.href.lastIndexOf("\\") + 1;
link = location.href.substring(0, Y);
link = link + "../../" + pkg + "/chtml/" + pkg + ".chm::/" + fn;
location.href = link;
}
</script>


<hr><div align="center">[Package <em>distr</em> version 2.0 <a href="00Index.html">Index]</a></div>

</body></html>
